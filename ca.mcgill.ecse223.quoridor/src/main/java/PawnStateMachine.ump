namespace ca.mcgill.ecse223.quoridor.controller;

use QuoridorGame.ump;


class PawnBehavior {

    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;

    pawnSM {
    	CanMove{
    		if(MakeMove()){
    		approved [isLegalStep(MoveDirection dir) == false && isLegalJump(MoveDirection dir) == false] -> CantMoveAndJump;
    		approved [isLegalStep(MoveDirection dir) == true && isLegalJump(MoveDirection dir) == false] -> CanMove;
   			approved [isLegalStep(MoveDirection dir) == false && isLegalJump(MoveDirection dir) == true] -> CanJump;
   			approved [isLegalStep(MoveDirection dir) == true && isLegalJump(MoveDirection dir) == true] -> CanMoveAndJump;
    		}
    		else if(MakeJump()){
    			illegalJump();
    		}
    	}
    	CanJump{
    		if(MakeJump()){
    		approved [isLegalStep(MoveDirection dir) == false && isLegalJump(MoveDirection dir) == false] -> CantMoveAndJump;
    		approved [isLegalStep(MoveDirection dir) == true && isLegalJump(MoveDirection dir) == false] -> CanMove;
   			approved [isLegalStep(MoveDirection dir) == false && isLegalJump(MoveDirection dir) == true] -> CanJump;
   			approved [isLegalStep(MoveDirection dir) == true && isLegalJump(MoveDirection dir) == true] -> CanMoveAndJump;
    		}
    		else if(MakeMove()){
    			illegalMove();
    		}
    	}
    	CanMoveAndJump{
    		if(MakeMove()||MakeJump()){
    		approved [isLegalStep(MoveDirection dir) == false && isLegalJump(MoveDirection dir) == false] -> CantMoveAndJump;
    		approved [isLegalStep(MoveDirection dir) == true && isLegalJump(MoveDirection dir) == false] -> CanMove;
   			approved [isLegalStep(MoveDirection dir) == false && isLegalJump(MoveDirection dir) == true] -> CanJump;
   			approved [isLegalStep(MoveDirection dir) == true && isLegalJump(MoveDirection dir) == true] -> CanMoveAndJump;
    		}
    	}
    	CantMoveAndJump{
   			if(MakeMove()){
   				illegalMove();
   			}
   			if(MakeJump()){
   				illegalJump();
   			}
    	}
	}

    // Returns the current row number of the pawn
    int getCurrentPawnRow() { 
		GamePosition curPos = currentGame.getCurrentPosition();
		Player white = currentGame.getWhitePlayer();
		if(curPos.getPlayerToMove().equals(white)) {
			return curPos.getWhitePosition().getTile().getRow();
			
		} else {
			return curPos.getBlackPosition().getTile().getRow();
		} 
	}
    // Returns the current column number of the pawn
    int getCurrentPawnColumn() { 
    	GamePosition curPos = currentGame.getCurrentPosition();
		Player white = currentGame.getWhitePlayer();
		if(curPos.getPlayerToMove().equals(white)) {
			return curPos.getWhitePosition().getTile().getColumn();
		
		} else {
			return curPos.getBlackPosition().getTile().getColumn();
		}
    }
    // Returns if it is legal to step in the given direction
    boolean isLegalStep(MoveDirection dir) { 
    	GamePosition curPos = currentGame.getCurrentPosition();
		Player white = currentGame.getWhitePlayer();
		int[] toCheckPos = new int[2];
		int[] existingPos = new int[2];
		if(curPos.getPlayerToMove().equals(white)) {
			toCheckPos[0] = curPos.getWhitePosition().getTile().getColumn();
			toCheckPos[1] = curPos.getWhitePosition().getTile().getRow();
			
			existingPos[0] = curPos.getBlackPosition().getTile().getColumn();
			existingPos[1] = curPos.getBlackPosition().getTile().getRow();
			
		} else {
			toCheckPos[0] = curPos.getBlackPosition().getTile().getColumn();
			toCheckPos[1] = curPos.getBlackPosition().getTile().getRow();
			
			existingPos[0] = curPos.getWhitePosition().getTile().getColumn();
			existingPos[1] = curPos.getWhitePosition().getTile().getRow();
		}
		//0 = column, 1 = row
		
		if(dir.equals(MoveDirection.North)) {
			if(toCheckPos[1] - 1 == existingPos[1] && toCheckPos[0] == existingPos[0]) return false;
			return QuoridorController.noWallBlock(curPos.getPlayerToMove(), -1, 0);
		} else if(dir.equals(MoveDirection.South)) {
			if(toCheckPos[1] + 1 == existingPos[1] && toCheckPos[0] == existingPos[0]) return false;
			return QuoridorController.noWallBlock(curPos.getPlayerToMove(), 1, 0);
		} else if(dir.equals(MoveDirection.East)) {
			if(toCheckPos[0] - 1 == existingPos[0] && toCheckPos[1] == existingPos[1]) return false;
			return QuoridorController.noWallBlock(curPos.getPlayerToMove(), 0, 1);
		} else if(dir.equals(MoveDirection.West)) {
			if(toCheckPos[0] + 1 == existingPos[0] && toCheckPos[1] == existingPos[1]) return false;
			return QuoridorController.noWallBlock(curPos.getPlayerToMove(), 0, -1);
		}
		return false;
     }
    // Returns if it is legal to jump in the given direction
    boolean isLegalJump(MoveDirection dir) { 
			GamePosition curPos = currentGame.getCurrentPosition();
			Player white = currentGame.getWhitePlayer();
			int whiteCol = curPos.getWhitePosition().getTile().getColumn();
			int whiteRow = curPos.getWhitePosition().getTile().getRow();
			int blackCol = curPos.getBlackPosition().getTile().getColumn();
			int blackRow = curPos.getBlackPosition().getTile().getRow();
			
			int rChange = 0, cChange = 0;
			if(dir == MoveDirection.North) rChange = -2;
			else if(dir == MoveDirection.South) rChange = 2;
			else if(dir == MoveDirection.East) cChange = 2;
			else if(dir == MoveDirection.South) rChange = -2;
			if(curPos.getPlayerToMove().equals(white)) {
				//Moving left or right wall check
				if(cChange != 0) {
					if(blackRow != whiteRow || blackCol != (whiteCol + cChange / 2) ) return false;
					whiteCol += cChange;
					if(whiteCol < 1 || whiteCol > 9) return false;
					for(WallMove w : QuoridorController.getWalls()) {
						if(w.getWallDirection() == Direction.Vertical) {
							
							//If left- check col -1, -2. If right- check col +0, +1
							int tmp;
							if(cChange < 0) tmp = -2;
							else tmp = 0;
							
							int checkCol = (whiteCol -cChange) + tmp;
							if((w.getTargetTile().getColumn() == checkCol ||w.getTargetTile().getColumn() == checkCol + 1)  && 
							   (w.getTargetTile().getRow() == whiteRow || w.getTargetTile().getRow() == whiteRow - 1)) {
								return false;
							}
						}
						//Horizontal Wall can't block right/left path
					}	
				}
				//Moving up or down wall check
				if(rChange != 0) {
					if(blackCol != whiteCol || blackRow != (whiteRow + rChange / 2) ) return false;
					whiteRow += rChange;
					if(whiteRow < 1 || whiteRow > 9) return false;
					for(WallMove w : QuoridorController.getWalls()) {
						
						if(w.getWallDirection() == Direction.Horizontal) {
							//If up- check row -1, -2. If down- check row +0, +1
							int tmp;
							if(rChange < 0) tmp = -2;
							else tmp = 0;
							
							int checkRow = (whiteRow -rChange) + tmp;
							
							if((w.getTargetTile().getRow() == checkRow || w.getTargetTile().getRow() == checkRow + 1)
								&& (w.getTargetTile().getColumn() == whiteCol || w.getTargetTile().getColumn() == whiteCol - 1)) {
								return false;
							}
						}
						//Vertical Wall can't block up/down path
					}
				}
				
				if((blackRow == whiteRow) && (blackCol == whiteCol)) return false;
			} else {
				//Moving left or right wall check
				if(cChange != 0) {
					if(blackRow != whiteRow || whiteCol != (blackCol + cChange / 2) ) return false;
					blackCol += cChange;
					if(blackCol < 1 || blackCol > 9) return false;
					for(WallMove w : QuoridorController.getWalls()) {
						if(w.getWallDirection() == Direction.Vertical) {
							
							//If left- check col -1, -2. If right- check col +0, +1
							int tmp;
							if(cChange < 0) tmp = -2;
							else tmp = 0;
							
							int checkCol = (blackCol -cChange) + tmp;

							if((w.getTargetTile().getColumn() == checkCol ||w.getTargetTile().getColumn() == checkCol + 1)  && 
							   (w.getTargetTile().getRow() == blackRow || w.getTargetTile().getRow() == blackRow - 1)) {
								return false;
							}
							
						}
						//Horizontal Wall can't block right/left path
					}	
				}
				//Moving up or down wall check
				if(rChange != 0) {
					if(blackCol != whiteCol || whiteRow != (blackRow + rChange / 2) ) return false;
					blackRow += rChange;
					if(blackRow < 1 || blackRow > 9) return false;
					for(WallMove w : QuoridorController.getWalls()) {
						if(w.getWallDirection() == Direction.Horizontal) {
							//If up- check row -1, -2. If down- check row +0, +1
							int tmp;
							if(rChange < 0) tmp = -2;
							else tmp = 0;
							
							int checkRow = (blackRow -rChange) + tmp;
							
							if((w.getTargetTile().getRow() == checkRow || w.getTargetTile().getRow() == checkRow + 1)
								&& (w.getTargetTile().getColumn() == blackCol || w.getTargetTile().getColumn() == blackCol - 1)) {
								return false;
							}

						}
						//Vertical Wall can't block up/down path
					}
				}
				
				if((blackRow == whiteRow) && (blackCol == whiteCol)) return false;
			}
			return true;   
    }

    // Action to be called when an illegal move is attempted
    void illegalMove() { 
    	//Taken care of in view?
    	//throw new RuntimeException("this is a illegal move");
    }
    void MakeMove(){
    
    
    }
    void MakeJump(){
    	
    }
    void illegalJump(){
    	//Taken care of in view?
    	//throw new RuntimeException("this is a illegal jump");
    }
    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North; }
}
